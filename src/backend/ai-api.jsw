// TTS WEBSITE V7 - AI Oracle API
// Backend module for AI image generation using Hugging Face FLUX-dev model
// This module bridges human intention (prompts) with AI consciousness (models)
//
// Dependencies: wix-fetch, wix-secrets-backend, wix-media-backend
// Related: BACKEND_IMPLEMENTATION.md, ARCHITECTURE.md
//
// EXPORTED FUNCTIONS:
// - channelSingleVision(prompt, imageUrl, options)    - Generate AI variations of single painting
// - fuseMultipleVisions(prompt, imageUrls, options)   - Blend multiple paintings
// - generateSingleImage(prompt, imageUrl, options)    - Alias for channelSingleVision
// - blendMultipleImages(prompt, imageUrls, options)   - Alias for fuseMultipleVisions
// - checkVisionStatus(generationId)                   - Check generation status (future)
// - saveCustomCreation(creationData)                  - Save creation to database
// - getUserCreations(userId, options)                 - Retrieve user's creations
// - updateCreationStatus(creationId, updates)         - Update creation record
//
// FEATURES:
// ‚úÖ AI image generation with Hugging Face FLUX-dev
// ‚úÖ Automatic image upload to Wix Media Manager
// ‚úÖ Mock mode for development/testing
// ‚úÖ Error handling with retry logic
// ‚úÖ Input validation and sanitization
// ‚úÖ Secure API key management via Wix Secrets
// ‚úÖ User-friendly error messages
// ‚úÖ Database persistence for custom creations

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

const HUGGING_FACE_API_URL = 'https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev';
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 2000; // 2 seconds
const RETRY_MULTIPLIER = 2; // Exponential backoff multiplier
const REQUEST_TIMEOUT = 60000; // 60 seconds
const MOCK_MODE_KEY = 'AI_MOCK_MODE'; // Environment variable to enable mock mode

// Default generation options
const DEFAULT_OPTIONS = {
    numVariations: 3,
    guidanceScale: 7.5,
    negativePrompt: 'blurry, low quality, distorted, ugly',
    seed: null, // Random seed if null
};

// ============================================================================
// MOCK DATA (FOR DEVELOPMENT)
// ============================================================================

const MOCK_IMAGES = [
    'https://images.unsplash.com/photo-1579783902614-a3fb3927b6a5?w=800',
    'https://images.unsplash.com/photo-1547891654-e66ed7ebb968?w=800',
    'https://images.unsplash.com/photo-1549887534-1541e9326642?w=800',
    'https://images.unsplash.com/photo-1549887552-cb1071d0e5f3?w=800',
];

/**
 * Generate mock response for testing without burning API credits
 * @private
 * @param {string} prompt - User's transformation intention
 * @param {number} numVariations - Number of variations to generate
 * @returns {Object} Mock generation results
 */
function generateMockResponse(prompt, numVariations = 3) {
    console.log('üîÆ [AI Oracle] Generating mock vision...');

    const generationId = `mock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const images = [];

    for (let i = 0; i < Math.min(numVariations, MOCK_IMAGES.length); i++) {
        images.push({
            url: MOCK_IMAGES[i],
            seed: Math.floor(Math.random() * 1000000),
            variation: i + 1,
        });
    }

    return {
        success: true,
        data: {
            generationId,
            images,
            metadata: {
                model: 'flux-dev (mock)',
                prompt,
                timestamp: new Date().toISOString(),
                mode: 'mock',
            },
        },
    };
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Sleep for a specified duration (used in retry logic)
 * @private
 * @param {number} ms - Milliseconds to sleep
 * @returns {Promise<void>}
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Generate a unique ID for generation tracking
 * @private
 * @returns {string} Unique generation ID
 */
function generateUniqueId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `gen_${timestamp}_${random}`;
}

/**
 * Validate prompt input
 * @private
 * @param {string} prompt - User's prompt
 * @throws {Error} If prompt is invalid
 */
function validatePrompt(prompt) {
    if (!prompt || typeof prompt !== 'string') {
        throw new Error('Prompt must be a non-empty string');
    }

    const trimmed = prompt.trim();

    if (trimmed.length === 0) {
        throw new Error('Prompt cannot be empty');
    }

    if (trimmed.length > 1000) {
        throw new Error('Prompt too long (max 1000 characters)');
    }

    return trimmed;
}

/**
 * Validate image URL(s)
 * @private
 * @param {string|Array<string>} imageUrls - URL or array of URLs
 * @throws {Error} If URLs are invalid
 */
function validateImageUrls(imageUrls) {
    const urls = Array.isArray(imageUrls) ? imageUrls : [imageUrls];

    if (urls.length === 0) {
        throw new Error('At least one image URL is required');
    }

    if (urls.length > 4) {
        throw new Error('Maximum 4 images can be blended');
    }

    for (const url of urls) {
        if (!url || typeof url !== 'string') {
            throw new Error('All image URLs must be non-empty strings');
        }

        try {
            new URL(url); // Validate URL format
        } catch (e) {
            throw new Error(`Invalid URL format: ${url}`);
        }
    }

    return urls;
}

/**
 * Check if mock mode is enabled
 * @private
 * @returns {Promise<boolean>}
 */
async function isMockModeEnabled() {
    try {
        const mockMode = await getSecret(MOCK_MODE_KEY);
        return mockMode === 'true' || mockMode === '1';
    } catch (e) {
        // If secret doesn't exist, default to false
        return false;
    }
}

/**
 * Get Hugging Face API key from secrets
 * @private
 * @returns {Promise<string>} API key
 * @throws {Error} If API key is not configured
 */
async function getApiKey() {
    try {
        const apiKey = await getSecret('HUGGING_FACE_API_KEY');

        if (!apiKey) {
            throw new Error('Hugging Face API key not configured');
        }

        return apiKey;
    } catch (error) {
        console.error('‚ùå [AI Oracle] Failed to retrieve API key:', error);
        throw new Error('API key configuration error. Please contact support.');
    }
}

/**
 * Retry an async operation with exponential backoff
 * @private
 * @param {Function} operation - Async function to retry
 * @param {number} maxRetries - Maximum number of retries
 * @param {string} context - Context for logging
 * @returns {Promise<any>} Result of successful operation
 * @throws {Error} If all retries fail
 */
async function retryWithBackoff(operation, maxRetries = MAX_RETRIES, context = 'operation') {
    let lastError;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`üîÑ [AI Oracle] Attempt ${attempt}/${maxRetries} for ${context}...`);
            return await operation();
        } catch (error) {
            lastError = error;

            if (attempt < maxRetries) {
                const delay = INITIAL_RETRY_DELAY * Math.pow(RETRY_MULTIPLIER, attempt - 1);
                console.warn(`‚ö†Ô∏è [AI Oracle] Attempt ${attempt} failed, retrying in ${delay}ms...`);
                console.warn(`   Error: ${error.message}`);
                await sleep(delay);
            }
        }
    }

    console.error(`‚ùå [AI Oracle] All ${maxRetries} attempts failed for ${context}`);
    throw lastError;
}

// ============================================================================
// HUGGING FACE API FUNCTIONS
// ============================================================================

/**
 * Call Hugging Face API for image generation
 * @private
 * @param {Object} payload - API payload
 * @param {string} apiKey - Hugging Face API key
 * @returns {Promise<Object>} API response
 * @throws {Error} If API call fails
 */
async function callHuggingFaceAPI(payload, apiKey) {
    const response = await fetch(HUGGING_FACE_API_URL, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    });

    // Check for rate limiting
    if (response.status === 429) {
        throw new Error('RATE_LIMIT: API rate limit exceeded. Please try again later.');
    }

    // Check for model loading (503)
    if (response.status === 503) {
        throw new Error('MODEL_LOADING: Model is loading. This usually takes 20-30 seconds.');
    }

    // Check for other errors
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API_ERROR: ${response.status} - ${errorText}`);
    }

    // For image generation, response is usually a blob
    const contentType = response.headers.get('content-type');

    if (contentType && contentType.includes('application/json')) {
        // If response is JSON, return it
        return await response.json();
    } else {
        // If response is image blob, convert to base64
        const blob = await response.blob();
        return blob;
    }
}

/**
 * Build enhanced prompt for better AI results
 * @private
 * @param {string} userPrompt - User's original prompt
 * @param {Object} options - Generation options
 * @returns {string} Enhanced prompt
 */
function buildEnhancedPrompt(userPrompt, options = {}) {
    // Add quality enhancers to the prompt
    const qualityTerms = 'high quality, detailed, professional, artistic';

    // Combine user prompt with quality enhancers
    let enhancedPrompt = `${userPrompt}, ${qualityTerms}`;

    return enhancedPrompt;
}

// ============================================================================
// PUBLIC API FUNCTIONS
// ============================================================================

/**
 * Generate AI variation of a single painting with a prompt
 * Channels the oracle to transform a single vision based on user intention
 *
 * @async
 * @param {string} prompt - User's transformation intention (what they want to create)
 * @param {string} imageUrl - URL of the original painting to transform
 * @param {Object} [options={}] - Generation options
 * @param {number} [options.numVariations=3] - Number of variations to generate (1-4)
 * @param {number} [options.guidanceScale=7.5] - How closely to follow prompt (1-20)
 * @param {string} [options.negativePrompt] - What to avoid in generation
 * @param {number} [options.seed] - Seed for reproducibility (null for random)
 *
 * @returns {Promise<Object>} Generation results
 * @returns {boolean} returns.success - Whether generation succeeded
 * @returns {Object} returns.data - Generation data (if success)
 * @returns {string} returns.data.generationId - Unique ID for this generation
 * @returns {Array<Object>} returns.data.images - Array of generated image variations
 * @returns {string} returns.data.images[].url - URL of generated image
 * @returns {number} returns.data.images[].seed - Seed used for this variation
 * @returns {number} returns.data.images[].variation - Variation number (1-4)
 * @returns {Object} returns.data.metadata - Generation metadata
 * @returns {string} returns.data.metadata.model - Model used
 * @returns {string} returns.data.metadata.prompt - Actual prompt used
 * @returns {string} returns.data.metadata.timestamp - ISO timestamp
 * @returns {Object} [returns.error] - Error details (if failed)
 * @returns {string} returns.error.message - User-friendly error message
 * @returns {string} returns.error.code - Error code
 * @returns {string} returns.error.timestamp - ISO timestamp
 *
 * @example
 * const result = await channelSingleVision(
 *   "transform into cosmic nebula",
 *   "https://example.com/painting.jpg",
 *   { numVariations: 3 }
 * );
 *
 * if (result.success) {
 *   console.log(`Generated ${result.data.images.length} variations`);
 *   result.data.images.forEach(img => {
 *     console.log(`Variation ${img.variation}: ${img.url}`);
 *   });
 * }
 */
export async function channelSingleVision(prompt, imageUrl, options = {}) {
    const startTime = Date.now();
    const generationId = generateUniqueId();

    console.log('üîÆ [AI Oracle] Channeling single vision...');
    console.log('   Prompt:', prompt);
    console.log('   Image URL:', imageUrl);
    console.log('   Generation ID:', generationId);

    try {
        // Validate inputs
        const validatedPrompt = validatePrompt(prompt);
        const [validatedImageUrl] = validateImageUrls(imageUrl);

        // Merge options with defaults
        const finalOptions = {
            ...DEFAULT_OPTIONS,
            ...options,
        };

        // Check if mock mode is enabled
        const mockMode = await isMockModeEnabled();

        if (mockMode) {
            console.log('üé≠ [AI Oracle] Mock mode enabled, returning test data');
            await sleep(1500); // Simulate API delay
            return generateMockResponse(validatedPrompt, finalOptions.numVariations);
        }

        // Get API key
        const apiKey = await getApiKey();

        // Build enhanced prompt
        const enhancedPrompt = buildEnhancedPrompt(validatedPrompt, finalOptions);

        // Prepare API payload
        const payload = {
            inputs: enhancedPrompt,
            parameters: {
                guidance_scale: finalOptions.guidanceScale,
                negative_prompt: finalOptions.negativePrompt,
                num_inference_steps: 30,
                seed: finalOptions.seed || Math.floor(Math.random() * 1000000),
            },
        };

        console.log('‚ú® [AI Oracle] Invoking the cosmic intelligence...');

        // Call API with retry logic
        const apiResponse = await retryWithBackoff(
            () => callHuggingFaceAPI(payload, apiKey),
            MAX_RETRIES,
            'single image generation'
        );

        // Process response
        // Note: For FLUX model, we typically get a single image
        // To generate multiple variations, we'd need to make multiple calls
        const images = [];
        const imageVariations = [];

        // Generate all variations first
        for (let i = 0; i < finalOptions.numVariations; i++) {
            const variantPayload = {
                ...payload,
                parameters: {
                    ...payload.parameters,
                    seed: finalOptions.seed || Math.floor(Math.random() * 1000000),
                },
            };

            console.log(`üé® [AI Oracle] Generating variation ${i + 1}/${finalOptions.numVariations}...`);

            const variantResponse = await callHuggingFaceAPI(variantPayload, apiKey);

            // Prepare for batch upload
            imageVariations.push({
                blob: variantResponse,
                baseName: `ai_single_${generationId}`,
                variation: i + 1,
                seed: variantPayload.parameters.seed,
            });
        }

        // Upload all variations to Wix Media Manager
        console.log('üì§ [AI Oracle] Uploading variations to media storage...');
        const uploadedImages = await uploadMultipleVariations(imageVariations);

        // Check if any uploads succeeded
        if (uploadedImages.length === 0) {
            throw new Error('Failed to upload any generated images to storage');
        }

        // Use uploaded images
        uploadedImages.forEach(img => {
            images.push({
                url: img.url,
                seed: img.seed,
                variation: img.variation,
            });
        });

        const duration = Date.now() - startTime;

        console.log(`‚úÖ [AI Oracle] Vision manifested successfully in ${duration}ms`);
        console.log(`   Generated ${images.length} variations`);

        return {
            success: true,
            data: {
                generationId,
                images,
                metadata: {
                    model: 'flux-dev',
                    prompt: enhancedPrompt,
                    originalPrompt: validatedPrompt,
                    timestamp: new Date().toISOString(),
                    duration,
                },
            },
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Vision channeling failed:', error);
        console.error('   Error details:', {
            message: error.message,
            stack: error.stack,
            generationId,
            timestamp: new Date().toISOString(),
        });

        return {
            success: false,
            error: {
                message: getUserFriendlyErrorMessage(error),
                code: getErrorCode(error),
                generationId,
                timestamp: new Date().toISOString(),
            },
        };
    }
}

/**
 * Blend multiple paintings into a new creation
 * Channels the oracle to fuse multiple energies into a unified vision
 *
 * @async
 * @param {string} prompt - Blending intention (how to combine the images)
 * @param {Array<string>} imageUrls - URLs of paintings to blend (2-4 images)
 * @param {Object} [options={}] - Generation options
 * @param {number} [options.numVariations=3] - Number of variations to generate (1-4)
 * @param {number} [options.guidanceScale=7.5] - How closely to follow prompt (1-20)
 * @param {string} [options.negativePrompt] - What to avoid in generation
 * @param {number} [options.seed] - Seed for reproducibility (null for random)
 *
 * @returns {Promise<Object>} Generation results (same format as channelSingleVision)
 *
 * @example
 * const result = await fuseMultipleVisions(
 *   "merge into a cosmic dreamscape",
 *   [
 *     "https://example.com/painting1.jpg",
 *     "https://example.com/painting2.jpg",
 *     "https://example.com/painting3.jpg"
 *   ],
 *   { numVariations: 2 }
 * );
 */
export async function fuseMultipleVisions(prompt, imageUrls, options = {}) {
    const startTime = Date.now();
    const generationId = generateUniqueId();

    console.log('üåÄ [AI Oracle] Fusing multiple visions...');
    console.log('   Prompt:', prompt);
    console.log('   Images:', imageUrls.length);
    console.log('   Generation ID:', generationId);

    try {
        // Validate inputs
        const validatedPrompt = validatePrompt(prompt);
        const validatedImageUrls = validateImageUrls(imageUrls);

        // Merge options with defaults
        const finalOptions = {
            ...DEFAULT_OPTIONS,
            ...options,
        };

        // Check if mock mode is enabled
        const mockMode = await isMockModeEnabled();

        if (mockMode) {
            console.log('üé≠ [AI Oracle] Mock mode enabled, returning test data');
            await sleep(2000); // Simulate longer API delay for blending
            return generateMockResponse(validatedPrompt, finalOptions.numVariations);
        }

        // Get API key
        const apiKey = await getApiKey();

        // Build enhanced prompt that mentions blending
        const blendingPrompt = `Blend and merge these artistic styles: ${validatedPrompt}`;
        const enhancedPrompt = buildEnhancedPrompt(blendingPrompt, finalOptions);

        // For FLUX model, we'll need to describe the blending in the prompt
        // since it doesn't natively support multi-image input
        // This is a limitation we'll document

        const payload = {
            inputs: enhancedPrompt,
            parameters: {
                guidance_scale: finalOptions.guidanceScale,
                negative_prompt: finalOptions.negativePrompt,
                num_inference_steps: 40, // More steps for blending
                seed: finalOptions.seed || Math.floor(Math.random() * 1000000),
            },
        };

        console.log('‚ú® [AI Oracle] Invoking alchemical fusion...');

        // Generate variations
        const images = [];
        const imageVariations = [];

        // Generate all blended variations
        for (let i = 0; i < finalOptions.numVariations; i++) {
            const variantPayload = {
                ...payload,
                parameters: {
                    ...payload.parameters,
                    seed: finalOptions.seed || Math.floor(Math.random() * 1000000),
                },
            };

            console.log(`üåÄ [AI Oracle] Generating blended variation ${i + 1}/${finalOptions.numVariations}...`);

            const variantResponse = await retryWithBackoff(
                () => callHuggingFaceAPI(variantPayload, apiKey),
                MAX_RETRIES,
                `blended variation ${i + 1}`
            );

            // Prepare for batch upload
            imageVariations.push({
                blob: variantResponse,
                baseName: `ai_blend_${generationId}`,
                variation: i + 1,
                seed: variantPayload.parameters.seed,
            });
        }

        // Upload all blended variations to Wix Media Manager
        console.log('üì§ [AI Oracle] Uploading blended variations to media storage...');
        const uploadedImages = await uploadMultipleVariations(imageVariations);

        // Check if any uploads succeeded
        if (uploadedImages.length === 0) {
            throw new Error('Failed to upload any blended images to storage');
        }

        // Use uploaded images
        uploadedImages.forEach(img => {
            images.push({
                url: img.url,
                seed: img.seed,
                variation: img.variation,
            });
        });

        const duration = Date.now() - startTime;

        console.log(`‚úÖ [AI Oracle] Visions fused successfully in ${duration}ms`);
        console.log(`   Generated ${images.length} blended variations`);

        return {
            success: true,
            data: {
                generationId,
                images,
                metadata: {
                    model: 'flux-dev',
                    prompt: enhancedPrompt,
                    originalPrompt: validatedPrompt,
                    blendedImages: validatedImageUrls.length,
                    timestamp: new Date().toISOString(),
                    duration,
                },
            },
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Vision fusion failed:', error);
        console.error('   Error details:', {
            message: error.message,
            stack: error.stack,
            generationId,
            timestamp: new Date().toISOString(),
        });

        return {
            success: false,
            error: {
                message: getUserFriendlyErrorMessage(error),
                code: getErrorCode(error),
                generationId,
                timestamp: new Date().toISOString(),
            },
        };
    }
}

/**
 * Get generation status for async operations
 * For future implementation when we add async generation queue
 *
 * @async
 * @param {string} generationId - Unique generation ID
 * @returns {Promise<Object>} Status information
 * @returns {boolean} returns.success - Whether query succeeded
 * @returns {Object} returns.data - Status data
 * @returns {string} returns.data.status - Status: 'pending', 'processing', 'completed', 'failed'
 * @returns {number} [returns.data.progress] - Progress percentage (0-100)
 * @returns {Object} [returns.data.result] - Generation result (if completed)
 *
 * @example
 * const status = await checkVisionStatus('gen_1234567890_abc123');
 * console.log(`Status: ${status.data.status}`);
 */
export async function checkVisionStatus(generationId) {
    console.log('üîç [AI Oracle] Checking vision status:', generationId);

    try {
        // Validate input
        if (!generationId || typeof generationId !== 'string') {
            throw new Error('Invalid generation ID');
        }

        // TODO: Implement actual status checking from database
        // For now, return not implemented

        return {
            success: false,
            error: {
                message: 'Status checking not yet implemented. All generations are synchronous.',
                code: 'NOT_IMPLEMENTED',
                timestamp: new Date().toISOString(),
            },
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Status check failed:', error);

        return {
            success: false,
            error: {
                message: error.message,
                code: 'STATUS_CHECK_FAILED',
                timestamp: new Date().toISOString(),
            },
        };
    }
}

// ============================================================================
// ERROR HANDLING UTILITIES
// ============================================================================

/**
 * Convert technical error to user-friendly message
 * Maintains immersion - no technical jargon exposed to users
 *
 * @private
 * @param {Error} error - The error object
 * @returns {string} User-friendly error message
 */
function getUserFriendlyErrorMessage(error) {
    const message = error.message || '';

    if (message.includes('RATE_LIMIT')) {
        return 'The cosmic connection is overwhelmed. Please try again in a few moments...';
    }

    if (message.includes('MODEL_LOADING')) {
        return 'The oracle is awakening. Please wait 20-30 seconds and try again...';
    }

    if (message.includes('API_ERROR')) {
        return 'The portal encountered turbulence. Please try again or contact support...';
    }

    if (message.includes('Prompt')) {
        return 'Your intention needs clarity. Please refine your prompt...';
    }

    if (message.includes('image URL')) {
        return 'The painting could not be accessed. Please verify the source...';
    }

    if (message.includes('API key')) {
        return 'The oracle connection is not configured. Please contact support...';
    }

    // Generic fallback
    return 'The cosmic energy faltered. Please try again or contact our support team...';
}

/**
 * Extract error code from error
 * @private
 * @param {Error} error - The error object
 * @returns {string} Error code
 */
function getErrorCode(error) {
    const message = error.message || '';

    if (message.includes('RATE_LIMIT')) return 'RATE_LIMIT';
    if (message.includes('MODEL_LOADING')) return 'MODEL_LOADING';
    if (message.includes('API_ERROR')) return 'API_ERROR';
    if (message.includes('Prompt')) return 'INVALID_PROMPT';
    if (message.includes('image URL')) return 'INVALID_IMAGE_URL';
    if (message.includes('API key')) return 'API_KEY_ERROR';

    return 'UNKNOWN_ERROR';
}

// ============================================================================
// CONVENIENCE ALIASES (Alternative Function Names)
// ============================================================================

/**
 * Generate AI variation of a single painting with a prompt
 * Alias for channelSingleVision() with simplified naming
 *
 * @async
 * @param {string} prompt - User's transformation intention
 * @param {string} imageUrl - URL of the original painting
 * @param {Object} [options={}] - Generation options (see channelSingleVision for details)
 * @returns {Promise<Object>} Generation results (see channelSingleVision for return format)
 *
 * @example
 * const result = await generateSingleImage(
 *   "transform into cosmic nebula",
 *   "https://example.com/painting.jpg"
 * );
 */
export async function generateSingleImage(prompt, imageUrl, options = {}) {
    console.log('üîÆ [AI Oracle] generateSingleImage() called (alias for channelSingleVision)');
    return await channelSingleVision(prompt, imageUrl, options);
}

/**
 * Blend multiple paintings into a new creation
 * Alias for fuseMultipleVisions() with simplified naming
 *
 * @async
 * @param {string} prompt - Blending intention
 * @param {Array<string>} imageUrls - URLs of paintings to blend (2-4 images)
 * @param {Object} [options={}] - Generation options (see fuseMultipleVisions for details)
 * @returns {Promise<Object>} Generation results (see fuseMultipleVisions for return format)
 *
 * @example
 * const result = await blendMultipleImages(
 *   "merge into a cosmic dreamscape",
 *   ["https://example.com/painting1.jpg", "https://example.com/painting2.jpg"]
 * );
 */
export async function blendMultipleImages(prompt, imageUrls, options = {}) {
    console.log('üåÄ [AI Oracle] blendMultipleImages() called (alias for fuseMultipleVisions)');
    return await fuseMultipleVisions(prompt, imageUrls, options);
}

// ============================================================================
// IMAGE STORAGE FUNCTIONS
// ============================================================================

/**
 * Upload generated image blob to Wix Media Manager
 * Manifests AI visions into permanent digital storage
 *
 * @async
 * @param {Blob} imageBlob - Image blob from API
 * @param {string} filename - Desired filename (without extension)
 * @param {Object} [options={}] - Upload options
 * @param {string} [options.folder='/ai-generated'] - Folder path in media manager
 * @param {string} [options.mimeType='image/png'] - MIME type
 * @returns {Promise<Object>} Upload result with URL and metadata
 * @returns {boolean} returns.success - Whether upload succeeded
 * @returns {Object} returns.data - Upload data (if success)
 * @returns {string} returns.data.fileUrl - Public URL of uploaded image
 * @returns {string} returns.data.fileName - Final filename
 * @returns {number} returns.data.width - Image width
 * @returns {number} returns.data.height - Image height
 * @returns {number} returns.data.fileSize - File size in bytes
 * @returns {Object} [returns.error] - Error details (if failed)
 *
 * @example
 * const result = await uploadToMediaManager(imageBlob, 'cosmic_nebula_001');
 * if (result.success) {
 *   console.log('Image URL:', result.data.fileUrl);
 * }
 */
async function uploadToMediaManager(imageBlob, filename, options = {}) {
    const {
        folder = '/ai-generated',
        mimeType = 'image/png',
    } = options;

    try {
        console.log('üíæ [AI Oracle] Uploading image to Wix Media Manager...');
        console.log('   Filename:', filename);
        console.log('   Folder:', folder);

        // Validate inputs
        if (!imageBlob) {
            throw new Error('Image blob is required');
        }

        if (!filename) {
            throw new Error('Filename is required');
        }

        // Import Wix Media Manager (dynamic import for modularity)
        const { mediaManager } = await import('wix-media-backend');

        // Convert blob to buffer if needed
        let imageBuffer;
        if (imageBlob instanceof ArrayBuffer) {
            imageBuffer = imageBlob;
        } else if (imageBlob.arrayBuffer) {
            imageBuffer = await imageBlob.arrayBuffer();
        } else {
            throw new Error('Invalid image blob format');
        }

        // Generate unique filename with timestamp
        const timestamp = Date.now();
        const uniqueFilename = `${filename}_${timestamp}.png`;

        // Upload to Wix Media Manager
        const uploadResult = await mediaManager.upload(
            folder,
            imageBuffer,
            uniqueFilename,
            {
                mediaOptions: {
                    mimeType,
                    mediaType: 'image',
                },
            }
        );

        console.log('‚úÖ [AI Oracle] Image uploaded successfully');
        console.log('   URL:', uploadResult.fileUrl);

        return {
            success: true,
            data: {
                fileUrl: uploadResult.fileUrl,
                fileName: uploadResult.fileName || uniqueFilename,
                width: uploadResult.width,
                height: uploadResult.height,
                fileSize: uploadResult.sizeInBytes,
            },
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Image upload failed:', error);

        return {
            success: false,
            error: {
                message: error.message || 'Failed to upload image',
                code: 'UPLOAD_FAILED',
                timestamp: new Date().toISOString(),
            },
        };
    }
}

/**
 * Upload multiple image variations to Wix Media Manager
 * Batch upload for efficiency
 *
 * @async
 * @param {Array<Object>} imageVariations - Array of image variations to upload
 * @param {Blob} imageVariations[].blob - Image blob
 * @param {string} imageVariations[].baseName - Base filename
 * @param {number} imageVariations[].variation - Variation number
 * @param {number} imageVariations[].seed - Seed used for generation
 * @returns {Promise<Array<Object>>} Array of upload results
 *
 * @example
 * const results = await uploadMultipleVariations([
 *   { blob: blob1, baseName: 'cosmic', variation: 1, seed: 42 },
 *   { blob: blob2, baseName: 'cosmic', variation: 2, seed: 123 }
 * ]);
 */
async function uploadMultipleVariations(imageVariations) {
    console.log(`üì¶ [AI Oracle] Uploading ${imageVariations.length} variations...`);

    const uploadPromises = imageVariations.map(async (variation, index) => {
        const filename = `${variation.baseName}_var${variation.variation}_seed${variation.seed}`;

        const result = await uploadToMediaManager(variation.blob, filename);

        if (result.success) {
            return {
                url: result.data.fileUrl,
                seed: variation.seed,
                variation: variation.variation,
                fileName: result.data.fileName,
            };
        } else {
            console.error(`Failed to upload variation ${variation.variation}:`, result.error);
            return null;
        }
    });

    const results = await Promise.all(uploadPromises);

    // Filter out failed uploads
    const successfulUploads = results.filter(r => r !== null);

    console.log(`‚úÖ [AI Oracle] Uploaded ${successfulUploads.length}/${imageVariations.length} variations`);

    return successfulUploads;
}

/**
 * Save custom AI creation to database with image URLs
 * Exported for use in other backend modules
 *
 * @async
 * @param {Object} creationData - Creation data to save
 * @param {string} creationData.userId - User ID or session ID
 * @param {string} creationData.userEmail - User email
 * @param {string} creationData.mode - 'manipulate' or 'blend'
 * @param {Array<string>} creationData.originalPaintingIds - IDs of source paintings
 * @param {string} creationData.userPrompt - Original user prompt
 * @param {string} creationData.enhancedPrompt - Enhanced prompt used for generation
 * @param {Array<Object>} creationData.generatedImages - Array of image objects
 * @param {Object} creationData.metadata - Additional metadata
 * @returns {Promise<Object>} Saved creation record
 *
 * @example
 * const result = await saveCustomCreation({
 *   userId: 'user123',
 *   mode: 'manipulate',
 *   originalPaintingIds: ['painting1'],
 *   userPrompt: 'cosmic nebula',
 *   enhancedPrompt: 'cosmic nebula, high quality...',
 *   generatedImages: [{ url: '...', seed: 42, variation: 1 }],
 *   metadata: { model: 'flux-dev', duration: 15000 }
 * });
 */
export async function saveCustomCreation(creationData) {
    try {
        console.log('üí´ [AI Oracle] Saving custom creation to database...');

        // Import wixData dynamically
        const wixData = await import('wix-data');

        // Validate required fields
        const requiredFields = ['userId', 'mode', 'originalPaintingIds', 'userPrompt'];
        for (const field of requiredFields) {
            if (!creationData[field]) {
                throw new Error(`Missing required field: ${field}`);
            }
        }

        // Set expiration (30 days from now)
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 30);

        // Prepare record for insertion
        const recordToInsert = {
            userId: creationData.userId,
            userEmail: creationData.userEmail || '',
            mode: creationData.mode,
            originalPaintingIds: creationData.originalPaintingIds,
            userPrompt: creationData.userPrompt,
            enhancedPrompt: creationData.enhancedPrompt || creationData.userPrompt,
            generatedImages: creationData.generatedImages || [],
            generationTime: creationData.metadata?.duration || 0,
            modelVersion: creationData.metadata?.model || 'flux-dev',
            status: 'generated',
            expiresAt,
            sessionId: creationData.sessionId || null,
        };

        // Insert into CustomCreations collection
        const result = await wixData.insert('CustomCreations', recordToInsert);

        console.log('‚úÖ [AI Oracle] Custom creation saved:', result._id);

        return {
            success: true,
            data: result,
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Failed to save custom creation:', error);

        return {
            success: false,
            error: {
                message: error.message,
                code: 'DATABASE_ERROR',
                timestamp: new Date().toISOString(),
            },
        };
    }
}

/**
 * Retrieve user's custom AI creations from database
 * Exported for use in frontend and other backend modules
 *
 * @async
 * @param {string} userId - User ID or session ID
 * @param {Object} [options={}] - Query options
 * @param {number} [options.limit=50] - Maximum number of items to retrieve
 * @param {string} [options.status] - Filter by status ('generated', 'selected', 'ordered')
 * @param {string} [options.mode] - Filter by mode ('manipulate', 'blend')
 * @returns {Promise<Object>} User's creations
 * @returns {boolean} returns.success - Whether query succeeded
 * @returns {Object} returns.data - Query results (if success)
 * @returns {Array<Object>} returns.data.creations - Array of creation objects
 * @returns {number} returns.data.totalCount - Total number of creations
 * @returns {Object} [returns.error] - Error details (if failed)
 *
 * @example
 * const result = await getUserCreations('user123', {
 *   limit: 20,
 *   status: 'generated'
 * });
 *
 * if (result.success) {
 *   console.log(`User has ${result.data.totalCount} creations`);
 *   result.data.creations.forEach(creation => {
 *     console.log(creation.userPrompt, creation.generatedImages);
 *   });
 * }
 */
export async function getUserCreations(userId, options = {}) {
    try {
        console.log('üîç [AI Oracle] Retrieving user creations...');
        console.log('   User ID:', userId);

        // Validate input
        if (!userId || typeof userId !== 'string') {
            throw new Error('Valid user ID is required');
        }

        // Import wixData dynamically
        const wixData = await import('wix-data');

        // Parse options
        const {
            limit = 50,
            status = null,
            mode = null,
        } = options;

        // Build query
        let query = wixData.query('CustomCreations')
            .eq('userId', userId)
            .descending('_createdDate')
            .limit(limit);

        // Add optional filters
        if (status) {
            query = query.eq('status', status);
        }

        if (mode) {
            query = query.eq('mode', mode);
        }

        // Execute query
        const result = await query.find();

        console.log(`‚úÖ [AI Oracle] Found ${result.items.length} creations`);

        return {
            success: true,
            data: {
                creations: result.items,
                totalCount: result.totalCount,
            },
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Failed to retrieve creations:', error);

        return {
            success: false,
            error: {
                message: error.message,
                code: 'QUERY_FAILED',
                timestamp: new Date().toISOString(),
            },
        };
    }
}

/**
 * Update creation status (e.g., when user selects a variation for ordering)
 * Exported for use in order management workflows
 *
 * @async
 * @param {string} creationId - Creation ID to update
 * @param {Object} updates - Fields to update
 * @param {string} [updates.status] - New status
 * @param {number} [updates.selectedVariation] - Selected variation number
 * @param {string} [updates.selectedImageUrl] - Selected image URL
 * @param {string} [updates.orderId] - Associated order ID
 * @returns {Promise<Object>} Update result
 *
 * @example
 * const result = await updateCreationStatus('creation123', {
 *   status: 'selected',
 *   selectedVariation: 2,
 *   selectedImageUrl: 'https://...'
 * });
 */
export async function updateCreationStatus(creationId, updates) {
    try {
        console.log('üìù [AI Oracle] Updating creation status...');
        console.log('   Creation ID:', creationId);

        // Validate inputs
        if (!creationId) {
            throw new Error('Creation ID is required');
        }

        if (!updates || typeof updates !== 'object') {
            throw new Error('Updates object is required');
        }

        // Import wixData dynamically
        const wixData = await import('wix-data');

        // Update the creation
        const result = await wixData.update('CustomCreations', {
            _id: creationId,
            ...updates,
        });

        console.log('‚úÖ [AI Oracle] Creation updated successfully');

        return {
            success: true,
            data: result,
        };

    } catch (error) {
        console.error('‚ùå [AI Oracle] Failed to update creation:', error);

        return {
            success: false,
            error: {
                message: error.message,
                code: 'UPDATE_FAILED',
                timestamp: new Date().toISOString(),
            },
        };
    }
}

// ============================================================================
// FUTURE ENHANCEMENTS
// ============================================================================

/**
 * TODO: Implement image upscaling for print quality
 *
 * @private
 * @param {string} imageUrl - URL of image to upscale
 * @param {number} scaleFactor - Scale factor (2x, 4x, etc)
 * @returns {Promise<string>} URL of upscaled image
 */
async function upscaleImageForPrint(imageUrl, scaleFactor = 4) {
    // Could use Real-ESRGAN or similar upscaling model
    throw new Error('Image upscaling not yet implemented');
}

/**
 * TODO: Implement style transfer from reference image
 *
 * @private
 * @param {string} contentImageUrl - Content image URL
 * @param {string} styleImageUrl - Style reference URL
 * @returns {Promise<string>} URL of stylized image
 */
async function applyStyleTransfer(contentImageUrl, styleImageUrl) {
    // Could use neural style transfer model
    throw new Error('Style transfer not yet implemented');
}
